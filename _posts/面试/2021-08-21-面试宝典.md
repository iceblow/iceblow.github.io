---
layout: post
title: 面试宝典
categories: 面试
description: 
keywords: 
---

本文梳理了Java的面试大纲，包括基础、多线程、数据库、JVM、框架、架构、中间件、设计模式等，同时在每个模块下汇总了在面试过程中常问的知识点，这些都是要重点掌握的。

由于面试内容较多，每次会更新部分，后面会持续更新！

### Java基础

#### String、StringBuilder、StringBuffer区别

都可以创建字符串，并拼接，String是不可变对象，+操作其实是创建了一个新的对象，线程安全；StringBuilder和buffer是可变对象，区别是builder非线程安全，buffer线程安全，对append方法加锁。[点击查看详细分析](https://iceblow.github.io/2020/01/01/String_StringBuilder_StringBuffer%E5%8C%BA%E5%88%AB/)

#### ArrayList和LinkList区别

Arraylist是数组，指定index查询效率高，O(1)，新增和删除会涉及数组的copy，效率低；扩容1.5倍，初始容量10,连续的内存空间；

LinkList是双向链表，随机查询需要遍历，效率低，O(n)；新增和删除，调整Node的前后指针，效率高，O(1)，内存空间不连续。[查看详细分析](https://iceblow.github.io/2020/01/02/ArrayList%E5%92%8CLinkList/)

#### HashMap原理

jdk1.8是数组+单向链表+红黑树，基于hash表，默认容量16，扩容2倍，加载因子0.75；

entry数组（hash/key/value/next），获取key的hash，确定在数组中的位置，在发生hash碰撞时（相同的hash）单向链表，在链表的长度为8时，由于效率较低，改为红黑树

##### 扩容与缩容

// TODO



#### ConcurrentHashMap原理

// TODO 

#### 接口和抽象类区别

##### 相同点：

都是抽象的，都可以有实现方法（jdk1.8+）（继承或实现类可以不用实现，也可以重写方法），都可以被继承。

##### 不同：

一个类只能继承一个抽象类（is-a），但可以实现多个接口（has-a)，抽象类的属性可以私有，接口的属性只能是public且static且final，全局静态不可变属性。

接口方法和属性都是public，而抽象类可以私有；

接口是可以多继承，但是抽象类只能单一继承；

抽象类可以实现接口；

##### 使用场景：

如果需要多继承关系，使用接口；接口主要是一种协议约定，上游不用关心底层实现。

抽象类主要是代码的复用，表示is-a关系；模板方法设计模式是抽象类的典型应用；

[点击查看详细分析](https://iceblow.github.io//2021/08/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB/)

### 多线程

#### 线程生命周期

新建（new）-就绪（runable)-运行（running）-blocked（阻塞）-死亡（dead）

#### 线程池

##### 原理

// TODO

##### 参数配置

(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);

#### 线程同步

// TODO

#### 锁

##### 悲观锁和乐观锁

悲观锁适合写操作多,乐观锁适合读操作多的场景

##### 自旋锁和适应性自旋锁

自旋锁（循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，默认10次）和适应性自旋锁（自旋次数不固定）。

##### synchronized锁的状态：无锁、偏向锁、轻量级锁、重量级锁

无锁：CAS

偏向锁：在无多线程竞争，锁总是由同一线程多次获得

轻量级锁：CAS操作和自旋来解决加锁

重量级锁:轻量级锁升级，再来一个线程获取锁

##### 公平锁和非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁；

非公平锁：非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待，优点是可以减少唤起线程的开销，整体的吞吐效率高，缺点是处于等待队列中的线程可能会饿死，

##### 可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁

###### 原理

// TODO 

##### 独享锁和共享锁

独享锁:互斥锁，该锁一次只能被一个线程所持有，synchronized和JUC中Lock的实现类就是

共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁

##### Synchronized和ReentrantLock区别

// TODO



### 框架

#### Spring

##### 注解

##### AOP

#### SpringBoot

##### 自动装配

#### SpringCloud

##### 组件

网关

负载均衡

注册中心

熔断

配置中心



#### Dubbo



### JVM

#### 性能优化

#### GC算法



### 数据库

#### mysql

##### 索引

B+树，非叶子节点不存储真实的数据，只存储指引搜索方向的数据项。IO次数取决于b+数的高度h，b+数是按照从左到右的顺序来建立搜索树的，最左匹配。

##### 优化

索引字段尽量小，主键优化（非空数字自增），外键优化（垂直拆分），索引优化（组合索引等），索引设置非空，索引命中率

##### 事务隔离级别

读提交、读未提交、可重复读（默认）、串行化

分布式事务

#### redis

##### 数据类型

##### 持久化方式

RDB：指定时间间隔快照存储，恢复时会丢失部分数据，适合用户备份

AOF：记录每次服务器写操作，文件体积较大，恢复时间较长

RDB+AOF： 当redis重启的时候会优先载入AOF文件来恢复原始的数据

##### 部署方式

单机

主从：主库写，从库读，主挂了没法写数据

哨兵：主从+哨兵（集群）

集群：多个主从，无中心架构，哨兵监控和故障转移，动态扩容，最少3节点（主从）

##### 过期策略

定期淘汰、定时淘汰、两者共同使用

##### 存在问题

缓存一致性、缓存雪崩、缓存击穿（无数据、集体失效）

##### 内存淘汰机制

内存不足时移除少用的key等多种

### 中间件

#### sharding-jdbc

##### 读写分离

一主一从或一主多从，主机负责写入数据，然后主机数据复制到从库，从库读取数据，

需要开启binlog，主从复制，

缺点：同步存在一定延迟，适合实时性一般的场景，查询可以强制主库路由。

##### 分库分表

水平分片和垂直分片。

分片策略

分片算法：标准分片和复合分片，Hint分片

如何扩容？节点数是2^N,扩容节点数起码*2

[数据库分片-基础篇](https://iceblow.github.io/2021/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87-%E5%9F%BA%E7%A1%80%E7%AF%87/)

[数据库分片-实战篇](https://iceblow.github.io/2021/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87-%E5%AE%9E%E6%88%98%E7%AF%87/)

#### 分布式事务

seata一站式分布式事务解决方案，二阶段提交模型，提供了 AT、TCC、SAGA 和 XA 事务模式

##### AT模式

两阶段提交协议的演变：

- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：
  - 提交异步化，非常快速地完成。
  - 回滚通过一阶段的回滚日志进行反向补偿。

- 一阶段本地事务提交前，需要确保先拿到 **全局锁** 。
- 拿不到 **全局锁** ，不能提交本地事务。
- 拿 **全局锁** 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。



### 设计模式



### 架构