---
layout: post
title: 悲观锁和乐观锁
categories: 多线程
description: 什么是悲观锁和乐观锁 
keywords: 并发
excerpt: 在计算机信息世界里，单机单线程时代没有锁的概念。自从出现了资源竞争，人们才意识到需要对部分场景的执行现场加锁，昭告天下，表明自己的“短暂”拥有（其实对于任何有形或无形的东西，拥有都不可能是永恒的）。
---

在计算机信息世界里，单机单线程时代没有锁的概念。自从出现了资源竞争，人们才意识到需要对部分场景的执行现场加锁，昭告天下，表明自己的“短暂”拥有（其实对于任何有形或无形的东西，拥有都不可能是永恒的）。

计算机的锁也是从开始的悲观锁，发展到后来的乐观锁、偏向锁、分段锁等。锁主要提供了两种特性 ，**互斥性和不可见性**。因为锁的存在，某些操作对外界来说是黑箱进行的，只有锁的持有者才知道对变量进行了什么修改。  

Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。我们通过特性将锁进行分组归类，再使用对比的方式进行介绍。下面是锁的总体分类图：

![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

由于篇幅有限，本文只介绍乐观锁和悲观锁。

### 悲观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

![](http://note.youdao.com/yws/public/resource/2b4dcb27ba48737b439c7daf8c39ce2a/xmlnote/AE6D8AF010A64C419D7C5F8AE94ECD28/7383)

如上图所示，线程A和B同时去操作同步资源，只有线程A会加锁成功，线程B等待；线程A操作资源结束后，释放锁，线程B尝试获取锁，然后加锁成功并操作资源。

下面是synchronized和ReentrantLock的调用示例：

```java
// ------------------------- 悲观锁的调用方式 -------------------------
// synchronized
public synchronized void testMethod() {
	// 操作同步资源
}

// ReentrantLock
private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
public void modifyPublicResources() {
	lock.lock();
	// 操作同步资源
	lock.unlock();
}
```

通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源。

### 乐观锁

乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。

乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

![](C:\Users\dxyin\AppData\Roaming\Typora\typora-user-images\image-20200916231218047.png)

```java
// ------------------------- 乐观锁的调用方式 -------------------------
private AtomicInteger atomicInteger = new AtomicInteger();  
// 需要保证多个线程使用的是同一个AtomicInteger
atomicInteger.incrementAndGet(); //执行自增1
```

通过调用方式示例，我们可以发现，乐观锁则直接去操作同步资源，并没有使用到锁。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。具体的原理会在下篇文章讲述。

### 使用场景

**悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。**

**乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。**
