---
layout: post
title: 2021面试宝典（停止更新）
categories: 面试
description: 
keywords: 
---

本文梳理了Java的面试大纲，包括基础、多线程、数据库、JVM、框架、架构、中间件、设计模式等，同时在每个模块下汇总了在面试过程中常问的知识点，解答部分精简了内容，如果需要详细分析的请点击每块后面的链接。

由于面试内容较多，每次会更新部分，后面会持续更新！

### Java基础

#### ArrayList和LinkList区别

Arraylist是数组，随机查询效率高O(1)，新增和删除会涉及数组的copy，效率低；扩容1.5倍，初始容量10,内存空间连续；

LinkList是双向链表，随机查询需要遍历，效率低O(n)；新增和删除，调整Node的前后指针，效率高O(1)，内存空间不连续。[查看详细分析](https://iceblow.github.io/2020/01/02/ArrayList%E5%92%8CLinkList/)

#### HashMap原理

jdk1.8是数组+单向链表+红黑树，基于hash表，默认容量16，扩容2倍，加载因子0.75；

entry数组（hash/key/value/next），获取key的hash，确定在数组中的位置，在发生hash碰撞时（相同的hash）单向链表，在链表的长度为8时，由于效率较低，改为红黑树；

红黑树（根节点必为黑色，任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点，是均衡二叉树）

##### 扩容与缩容

当数组中元素个数超过（容量*加载因子）的时候，为了减少hash碰撞，需要扩容2倍容量

扩容时key需要重新hash

#### ConcurrentHashMap原理

数据结构：数组＋链表＋红黑树

并发原理：cas乐观锁+synchronized锁

PUT操作：根据key的hash值定位数组位置，cas获取到头节点，使用synchronized锁锁住头节点，遍历链表或红黑树进行插入操作

#### 接口和抽象类区别

相同点：都是抽象，可以有实现方法，都可以被继承。

不同：

一个类只能继承一个抽象类（is-a），但可以实现多个接口（has-a)，

抽象类的属性方法可以私有，接口的属性只能是public且static且final,方法public

接口是可以多继承，但是抽象类只能单一继承；

抽象类可以实现接口；

##### 使用场景：

如果需要多继承关系，使用接口；接口主要是一种协议约定，上游不用关心底层实现。

抽象类主要是代码的复用，表示is-a关系；模板方法设计模式是抽象类的典型应用；

[点击查看详细分析](https://iceblow.github.io//2021/08/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB/)

### 多线程

#### 线程生命周期

新建（new）-就绪（runable)-运行（running）-blocked（阻塞）-死亡（dead）

#### 线程池

##### 原理

生产者消费者模型？

##### 参数配置

```java
(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
```

先创建核心线程的数量，如果不够用，需要放入阻塞队列，如果队列满了，需要创建额外的线程，直至达到最大线程数，在多的任务就只能执行拒绝策略。

#### 线程同步

synchronized同步方法或代码块

volatile修饰属性（不提供原子性操作）

重入锁（ReenreantLock）

使用局部变量ThreadLocal实现线程同步

使用阻塞队列实现线程同步？

使用原子变量实现线程同步，AtomicInteger等

#### 锁

##### 悲观锁和乐观锁

悲观锁适合写操作多,乐观锁适合读操作多的场景

##### 自旋锁和适应性自旋锁

自旋锁（循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，默认10次）和适应性自旋锁（自旋次数不固定）。

##### synchronized锁的状态：无锁、偏向锁、轻量级锁、重量级锁

无锁：CAS

偏向锁：在无多线程竞争，锁总是由同一线程多次获得；Mark Word里存储锁偏向的线程ID。

轻量级锁：CAS操作和自旋来解决加锁

重量级锁:轻量级锁升级，再来一个线程获取锁

为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。

![img](http://qiniuyun.jeesoul.com/img/20220216104506.png)

对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。锁升级后，锁的状态值会发生变化。

[查看详细分析](https://iceblow.github.io/2020/02/01/%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81/)

##### 公平锁和非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁；

非公平锁：非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待，优点是可以减少唤起线程的开销，整体的吞吐效率高，缺点是处于等待队列中的线程可能会饿死。

##### 可重入锁和非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁

###### 原理

首先ReentrantLock和NonReentrantLock（可能死锁）都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。

[查询详细分析](https://iceblow.github.io/2020/02/01/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8C%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/)

##### 独享锁和共享锁

独享锁:互斥锁，该锁一次只能被一个线程所持有，synchronized和JUC中Lock的实现类就是

共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁

##### Synchronized和ReentrantLock区别

Synchronized是JVM实现，无需手动加锁释放锁，ReentrantLock是并发包实现，可以有多个种类，需要手动加锁释放锁。

#### AQS原理

AQS的实现依赖于内部的同步队列，它是一个FIFO双向队列，如果当前线程获取同步状态state失败，AQS会将该线程以及等待状态等信息构造成一个Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。

#### CountDownLatch原理

内部类Sync（计数器，获取锁，释放锁）继承AQS。

核心方法

```java
// 初始化多个线程数(计数器)
public CountDownLatch(int count);
//计数器-1
public void countDown();
//等待，直至计数器为0或超时
public boolean await(long timeout, TimeUnit unit);
```

### 框架

#### Spring

##### AOP原理

//TODO

##### 如何解决循环依赖问题

单例Bean三级缓存，

- A创建过程中需要B，于是**A将自己放到三级缓存**里面，去**实例化B**
- B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A然后把三级缓存里面的这个**A放到二级缓存里面，并删除三级缓存里面的A**
- **B顺利初始化完毕**，将自己放到一级缓存里面（**此时B里面的A依然是创建中状态**）然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并**将A放到一级缓存**中。

##### @Autowire和@Resource区别

@Autowire bytype,@Resource byName(推荐使用)

#### SpringBoot

##### 自动装配

@SpringBootApplication注解---@EnableAutoConfiguration注解---AutoConfigurationImportSelector类

ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于**获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中**。

其中getAutoConfigurationEntry()方法，

- 先判断自动装配开关是否打开（默认开），
- 获取EnableAutoConfiguration注解中的 exclude 和 excludeName
- 获取需要自动装配的所有配置类，读取META-INF/spring.factories文件
- 不会加载所有配置，只有@ConditionalOnXXX 中的所有条件都满足，该类才会生效。

#### SpringCloud Alibaba

##### 组件

###### 网关

Springcloud gateway，路由、鉴权、日志等

###### 负载均衡

ribbon，策略包括轮询、随机、权重、轮询重试等

###### 服务注册与发现

nacos discovery

###### 熔断

Sentinel,以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

###### 配置中心

nacos config，客户端长轮询，主动拉取服务端，

#### Dubbo

##### 服务发现

<img src="http://qiniuyun.jeesoul.com/img/20220301142026.png" alt="//imgs/architecture.png" style="zoom:50%;" />

服务发现的一个核心组件是注册中心，Provider 注册地址到注册中心，Consumer 从注册中心读取和订阅 Provider 地址列表。 因此，要启用服务发现，需要为 Dubbo 增加注册中心配置，如zk，nacos等。

**注册-订阅-通知-调用-监控。**

##### 协议

dubbo3通讯协议不仅包括dubbo2原生协议，还包括 gRPC、Thrift、JsonRPC、Hessian2、REST 等

### JVM

#### 内存模型

JVM有本地方法栈、虚拟机栈、程序计数器、堆、方法区。

Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1

#### 性能优化

设置堆内存，-Xms最小，-Xmx最大，新生代和老年代比例，合适的GC算法等

#### GC算法

参考标准：吞吐量、最大暂停时间、堆的使用效率，访问的局部性

复制（浪费内存）、标记清除（内存碎片）、标记压缩、引用计数、分代收集算法。

#### 垃圾回收器

JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合

推荐G1

### 数据库

#### mysql

##### 索引

B+树，非叶子节点不存储真实的数据，只存储指引搜索方向的数据项。IO次数取决于b+数的高度h，b+数是按照从左到右的顺序来建立搜索树的，最左匹配。

##### 优化

索引字段尽量小，主键优化（非空数字自增），外键优化（垂直拆分），索引优化（组合索引等），索引设置非空，索引命中率

##### 事务隔离级别

读提交、读未提交、可重复读（默认）、串行化

分布式事务

#### redis

##### 数据类型

String、Hash、List、Set、zset、Bitmap等

##### 使用场景

缓存、分布式锁、限流、发布/订阅

##### 持久化方式

RDB：指定时间间隔快照存储，恢复时会丢失部分数据，适合用户备份

AOF：记录每次服务器写操作，文件体积较大，恢复时间较长

RDB+AOF： 当redis重启的时候会优先载入AOF文件来恢复原始的数据

##### 部署方式

单机

主从：主库写，从库读，主挂了没法写数据

哨兵：主从+哨兵（集群）

集群：多个主从，无中心架构，哨兵监控和故障转移，动态扩容，最少3节点（主从）

##### 过期策略

定期淘汰、定时淘汰、两者共同使用

##### 存在问题

缓存一致性、缓存雪崩、缓存击穿（无数据、集体失效）

##### 内存淘汰机制

内存不足时移除少用的key等多种

##### rehash、hotkey、bigkey

扩容需要对之前的键值对进行重新计算也就是rehash，

渐进式hash：利用了两个哈希表进行的 , 有点类似数据库的迁移 , 读的时候先读旧库 , 读不到读新库 , 写的时候只写新库 ; 其他旧数据一点点的往新库上迁移。

hotkey:热点key

bigkey:超过10KB

### 中间件

#### sharding-jdbc

##### 原理

当Sharding-JDBC接受到一条SQL，会陆续执行 SQL解析 -> 查询优化 -> SQL路由 -> SQL改写 -> SQL执行 ->结果归并 ，最终返回执行结果。 

##### 读写分离

一主一从或一主多从，主机负责写入数据，然后主机数据复制到从库，从库读取数据，

需要开启binlog，主从复制，

缺点：同步存在一定延迟，适合实时性一般的场景，查询可以强制主库路由。

##### 分库分表

水平分片和垂直分片。

分片策略

分片算法：标准分片和复合分片，Hint分片

##### 如何扩容

主从复制扩容（后删无用数据），

sharding-jdbc中间件扩容，

中间件根据新路由规则扩容到新节点，老节点的数据只多，然后删除

节点数是2^N,扩容节点数起码*2

[数据库分片-基础篇](https://iceblow.github.io/2021/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87-%E5%9F%BA%E7%A1%80%E7%AF%87/)

[数据库分片-实战篇](https://iceblow.github.io/2021/12/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87-%E5%AE%9E%E6%88%98%E7%AF%87/)

#### 分布式事务

seata一站式分布式事务解决方案，二阶段提交模型，提供了 AT、TCC、SAGA 和 XA 事务模式

AT 模式（[参考链接 TBD](http://seata.io/zh-cn/docs/overview/what-is-seata.html)）基于 **支持本地 ACID 事务** 的 **关系型数据库**。

事务1---获取本地锁---prepare---获取全局锁---localcommit---释放本地锁。

事务2---获取本地锁---prepare---获取全局锁（重试）---拿到全局锁---localcommit---释放本地锁

##### AT模式

两阶段提交协议的演变：

- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：
  - 提交异步化，非常快速地完成。
  - 回滚通过一阶段的回滚日志进行反向补偿。
- 一阶段本地事务提交前，需要确保先拿到 **全局锁** 。
- 拿不到 **全局锁** ，不能提交本地事务。
- 拿 **全局锁** 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

#### zookeeper

分布式配置服务、同步服务和命名注册。

1、同一级节点 key 名称是唯一的

2、创建节点时，必须要带上全路径

3、session 关闭，临时节点清除

4、自动创建顺序节点

5、watch 机制，监听节点变化

6、delete 命令只能一层一层删除

可以实现发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

分布式排它锁：利用 zookeeper 的同级节点的唯一性特性，在需要获取排他锁时，所有的客户端试图通过调用 create() 接口，在 某节点下创建临时子节点 ，最终只有一个客户端能创建成功，那么此客户端就获得了分布式锁。同时，所有没有获取到锁的客户端可以在子节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。

#### MQ

##### 核心特性

消息的可靠传递：确保不丢消息；

Cluster：支持集群，确保不会因为某个节点宕机导致服务不可用，当然也不能丢消息；

性能：具备足够好的性能，能满足绝大多数场景的性能要求。

主流对比

| 名称     | 优点                                 | 缺点                   |
| -------- | ------------------------------------ | ---------------------- |
| RabbitMQ | 轻量级，支持多语言，路由规则灵活     | 性能差，消息积压不友好 |
| RocketMQ | 性能高，响应时延低                   | 周边生态不足           |
| Kafka    | 吞吐量高，支持大数据和流计算         | 时延高                 |
| Pulsar   | 存储和计算分离的设计，性能高，时延低 | 未知                   |



### 架构与设计

#### 秒杀系统

高性能：动静分离、热点数据、流量削峰（排队、答题、分层过滤）、分库分表

一致性：减库存（下单减库存）可用数据或或者缓存

高可用：降级、限流、拒绝服务、熔断等

页面静态化-CDN加速-热点数据缓存-mq削峰填谷-下单减库存-分布式锁-数据库兜底

[点击查看全文分析](https://iceblow.github.io/2022/02/14/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/)

#### 分布式锁

redis分布式锁（见中间件zk）

本地数据库，只有更新成功的才能拿到锁，

zookeeper节点的唯一性和有序性

#### 限流

固定、滑动时间窗、令牌桶算法、漏桶算法

#### 高性能架构

##### 读写分离

将数据库读写操作分散到不同的节点上。存在问题：复制延迟和分配问题。

##### 分库分表

按照业务模块将数据分散到不同的数据库服务器和表。存在问题：业务多维度查询，分页、join等。

##### NoSQL

K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。

文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。

列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。

全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表

缺点：没有事务，不能联表查询。

##### 缓存架构

基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。

存在问题：缓存穿透（缓存中无数据，设置默认值），缓存雪崩（缓存过期，更新锁机制和后台更新机制、过期时间加随机数），缓存热点数据（复制多份缓存副本，将请求分散到多个缓存服务器上）

##### 负载均衡

解决并发压力，提高应用处理性能；提供故障转移，实现高可用；提升服务扩展性；安全防护

高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。

主流包括：DNS 负载均衡、硬件负载均衡和软件负载均衡（Nginx等），算法包括：轮询、加权轮询、负载最低、性能最优、Hash等。

#### 高可用架构

##### 双机架构

主备、主从、主备 / 主从切换和主主。

##### 集群和分区

数据集中集群：主机如何将数据复制给备机，备机如何检测主机状态，主机故障后，如何决定新的主机，举例：Zk。适合数据量不大，集群机器数量不多的场景。

数据分散集群：均衡性、容错性、可伸缩性

分区复制规则有三种：集中式、互备式和独立式

##### 异地多活架构

##### 接口级故障

降级：将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。

熔断：熔断是指按照规则停掉依赖外部接口的访问，防止外部接口故障导致自己的系统出故障。

限流：限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。

排队：限流是直接拒绝用户，排队是让用户等待一段时间。

#### 可扩展架构

面向流程：分层架构和SOA

服务：微服务

功能拆分：更细粒度。

微服务拆分包括基于业务逻辑拆分、基于可扩展拆分、基于可靠性拆分、基于性能拆分。



### 系统安全

#### JWT

客户端存储、服务端校验，无状态已扩展，适合过期时间短、一次性认证的场景。

#### OAuth2.0

