---
layout: post
title: 常见同步类
categories: [多线程]
description: some word here
keywords: keyword1, keyword2
---

之前的文章我们已经分析过AQS的原理，那么本文我们就详解下常见的同步类，重点理解实现细节的差异和使用场景。

### 常见同步类

以ReentrantLock为例，

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

其他同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。

### ReentrantLock

ReentrantLock实现了Lock接口，同时定义同步器内部类（继承AQS），同时还定义了公平和非公平的同步器。

state初始化为0，表示未锁定状态。

A线程lock()时，会调用tryAcquire()独占该锁并将state+1。

此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。

当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。

但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

```java
// 实现Lock接口
public class ReentrantLock implements Lock{
  
  // 同步器内部类
	private final Sync sync;
  
  // 定义内部类（继承AQS）
  abstract static class Sync extends AbstractQueuedSynchronizer {}  
  
  // 非公平锁的同步器
   static final class NonfairSync extends Sync {}
  
  // 公平锁的同步器
  static final class FairSync extends Sync {
    // 公平锁的区别在于，获取锁的时候判断当前线程是否同步队列的head节点
  }
  
  // 默认非公平锁
  public ReentrantLock() {
    sync = new NonfairSync();
  }

  // 构造公平锁还是非公平锁
  public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
  }
}
```

// TODO 
