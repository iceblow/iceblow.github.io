---
layout: post
title: 2022年面试准备
categories: [面试]
description: 面试
keywords: 面试, keyword2
---

2022年，面试准备。

### 自我介绍

大家好，我叫XXX，从事java开发有10年工作经验。最近就职于SHPL，担任研发经理职位。

公司是做线上零售业务，我们开发了运营系统、内部信息化系统、微信第三方平台、微信支付、BI可视化分析工具等，个人负责需求分析、架构设计、技术选型、功能开发、运维等。技术栈包括Springcloud alibaba微服务框架、redis、es、metabase等。

上一家公司是在XF消费者BG，担任研发组长，我们做了TJZM的产品，个人负责系统架构优化、重构、功能研发等，技术栈有Springcloud微服务框架等。

之前还在YPSX做了到家小程序，包括用户服务、权限服务、商户服务、营销服务（拼团秒杀）等，技术栈包括dubbo、grpc微服务框架、pulsar消息系统等。

擅长并发编程，数据库设计和调优，架构设计，项目管理等工作，业余时间学习架构知识、源码，并沉淀学习心得。

### 多线程

#### AQS

| AQS核心               | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| 内部类Node            | 有共享或独占模式、waitStatus等属性                           |
| FIFO队列              | 多线程争用资源被阻塞时会进入此队列                           |
| int state             | 同步状态，可自定义具体实现                                   |
| isHeldExclusively()   | 是否独占模式                                                 |
| tryAcquire(int)       | 独占方式。尝试获取资源，成功则返回true，失败则返回false      |
| tryRelease(int)       | 独占方式。尝试释放资源，成功则返回true，失败则返回false      |
| tryAcquireShared(int) | 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源 |
| tryReleaseShared(int) | 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 |

#### 常用同步类



### Spring原理

#### Springboot自动配置

<img src="https://cdn.jsdelivr.net/gh/iceblow/images/20220321175401.png" alt="image-20220321175401454" style="zoom: 33%;" />

#### 循环依赖

![image-20200706161709829](https://cdn.jsdelivr.net/gh/iceblow/images/20220324175501.png)

Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（`singletonObjects`）,二级缓存为早期曝光对象`earlySingletonObjects`，三级缓存为早期曝光对象工厂（`singletonFactories`）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！

”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“

答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。

### 秒杀系统

| 设计方案     | 实现                                                 |
| ------------ | ---------------------------------------------------- |
| 独立部署     | 独立web服务器，后台服务、独立域名                    |
| 页面设计简单 | 简化页面商品信息                                     |
| 多级缓存     | 浏览器或APP缓存、CDN缓存、服务端本地缓存、分布式缓存 |
| 下单限流     | 全局下单计数器（redis实现）                          |

### 微服务框架

#### Springcloud、dubbo比较

| 功能组件 | Spring Cloud                   | Dubbo                                              |
| -------- | ------------------------------ | -------------------------------------------------- |
| 底层     | Http协议Rest接口通信           | Netty NIO框架，TCP协议，Hession序列化完成RPC通信， |
| 通讯协议 | rest                           | dubbo、rest、grpc、Thrift，还有Dubbo3、dubbo2等    |
| 性能     | 报文更大占用带宽大，但rest灵活 | 性能较好，但强依赖                                 |

#### 服务治理





#### 组件原理

### 架构设计

#### 架构图

<img src="https://cdn.jsdelivr.net/gh/iceblow/images/20220324174438.png" alt="image-20220324174438773" style="zoom: 33%;" />

### 数据结构和算法

#### 限流算法

| 限流算法 | 原理                                   | 优点                       | 缺点                               | 场景                       |
| -------- | -------------------------------------- | -------------------------- | ---------------------------------- | -------------------------- |
| 固定窗口 | 统计一个周期内的请求量                 | 实现简单                   | 临界点问题                         | 普通限流                   |
| 滑动窗口 | 一个周期分为多个小窗口                 | 限流粒度较细               | 临界点问题，实现稍复杂             | 普通限流                   |
| 漏桶     | 桶里是请求，总量控制                   | 桶大小可控，可应对突发流量 | 无法精确控制流出速度               | 秒杀                       |
| 令牌桶   | 桶里是令牌，请求从桶里拿令牌，速率控制 | 速率可控                   | 突发大流量会丢弃许多请求，实现复杂 | 平稳限流，如访问第三方服务 |

### Redis

#### 持久化

| 持久化方式 | 原理                                                        | 优点                                         | 缺点                               |
| ---------- | ----------------------------------------------------------- | -------------------------------------------- | ---------------------------------- |
| RDB        | 定期快照存储                                                | 速度快，适合备份                             | 丢失部分数据，fork的子线程占用内存 |
| AOF        | 追加写，记录每次对服务器写的操作                            | 数据完整                                     | 文件体积大，速度慢                 |
| 混合模式   | 内存快照以⼀定的频率执⾏，在两次快照之间，使⽤ AOF ⽇志记录 | 不会出现⽂件过⼤的情况了，也可以避免重写开销 |                                    |

#### zset有序集合

跳表是链表加多级索引的结构，原理是单向链表的二分查找。

<img src="https://cdn.jsdelivr.net/gh/iceblow/images/20220327003100.jpg" alt="img" style="zoom: 33%;" />

#### 部署方式

| 部署方式 | 原理                                                         | 缺点                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------ |
| 单机     | 单机部署                                                     | 单机故障，性能差                     |
| 主从     | 主从读写分离：<br>主从均可读<br>写交给主库，然后同步到从库（全量、增量） | 主库挂了不能提供写，故障不能自动转移 |
| 哨兵     | 哨兵集群：哨兵是⼀个运⾏在特殊模式下的 Redis 进程<br>监控:周期性地给所有的主从库发送 PING 命令<br/>选举:主观客观下线、筛选打分三轮选主(优先级、同步最接近、ID最小）<br/>通知: 从库同步新主库，原主库下线 |                                      |
| 集群     | ⽤哈希槽来处理数据和实例之间的映射关系,key使用crc16算法对16384取模后定位到槽<br/>客户端缓存hash槽信息，重定向机制move |                                      |

#### 渐进式Hash

Redis 默认使⽤了两个全局哈希表：哈希表12。默认使⽤ 1， 2 并没有被分配空间。随着数据逐步增多，Redis 开始执⾏ rehash

- 给哈希表 2 分配更⼤的空间
- 把哈希表 1 中的数据重新映射并拷⻉到哈希表 2 中（渐进式，只写入新表，先查老表查不到再查新表）
- 释放哈希表 1 的空间

#### LRU缓存淘汰算法

自己实现：单向链表，头部放最新数据。判断是否新数据（遍历是否存在），如果已存在，删除所在的节点，然后放在头节点；如果是新数据，判断是否有内存，没有的话就删除尾部节点，新数据都是放在头节点的。

### Mysql

#### B+树

特点：m 叉树只存储索引（非叶子节点），并不真正存储数据，通过链表将叶子节点串联在一起，这样可以方便按区间查找。

IO次数取决于b+数的高度h，当前数据表的数据为N，每个磁盘块的数据项的数量是m = 磁盘块的大小 / 数据项的大小（m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点）。

3层的b+树可以表示上百万的数据。

![公式](https://cdn.jsdelivr.net/gh/iceblow/images/20220321095252.png)

### Zookeeper

#### 原理

分布式协调解决方案

#### 分布式锁

排它锁：在lock节点下创建临时子节点 ，只有一个客户端创建成功获取锁，未获取锁的节点同时在lock节点下创建子节点的watch变更事件，可以重新获取锁。

共享锁：创建临时顺序节点，对于写请求，如果自己不是序号最小的子节点，那么就进入等待；对于读请求如果所有比自己小的子节点都是读请求可以获取锁。

### 系统排查

### 分布式技术

#### 分布式事务

| Seata模式对比 | AT模式                                                       | TCC模式                                                      |
| :-----------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|     场景      | 支持本地 ACID 事务的关系型数据库<br/>Java 应用，通过 JDBC 访问数据库 | 不依赖于底层数据资源的事务支持                               |
|   整体机制    | 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁<br/>二阶段：提交异步化，回滚通过一阶段的回滚日志进行反向补偿 | 两阶段提交模型：<br/>一阶段 prepare 行为<br/>二阶段 commit 或 rollback |
|    一阶段     | 事务1：获取本地锁，update语句，获取全局锁，提交本地事务，释放本地锁<br/>事务2：获取本地锁，update语句，重试等待全局锁 | 调用 **自定义** 的 prepare 逻辑                              |
|  二阶段提交   | 事务1：全局提交，释放全局锁<br/>事务2：等到全局锁，提交本地事务，释放本地锁 | 调用 **自定义** 的 commit 逻辑。                             |
|  二阶段回滚   | 事务1：重新获取本地锁（等待2释放），反向补偿更新提交<br/>事务2：等待全局锁超时，回滚本地事务，释放本地锁 | 调用 **自定义** 的 rollback 逻辑                             |

#### 分布式锁

| 排它锁 | mysql                                                        | zookeeper                                                    | redis                              |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 原理   | 表锁(不推荐）：写入一条记录，插入成功的获取到锁，删除记录释放锁<br/>乐观锁：行锁，CAS | X节点下创建子节点，只有一个client成功，其他节点创建子节点变更事件，重新获取锁 | redission实现多种锁                |
| 优点   | 简单、容易实现                                               | 高可用，不可重入                                             | 高可用、高性能                     |
| 缺点   | 单机故障、性能差、死锁                                       | 实现复杂，性能低于redis                                      | 锁失效时间控制不稳定，稳定性低于ZK |
| 场景   | 适合并发低、性能不高场景                                     | 适合大部分场景，性能要求不高                                 | 适合高性能、高并发场景             |

