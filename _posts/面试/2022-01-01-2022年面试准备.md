---
layout: post
title: 2022年面试准备
categories: [面试]
description: 面试
keywords: 面试, keyword2
---

2022年，面试准备。

### JAVA基础

### JVM



### 多线程

线程生命周期：新建（new）-就绪（runable)-运行（running）-blocked（阻塞）-死亡（dead）

#### 线程池

配置参数如下：

```java
(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
```

#### 锁

| 锁的类型     | 原理                                                         | 场景/特点          |
| ------------ | ------------------------------------------------------------ | ------------------ |
| 乐观锁       | CAS                                                          | 写少读多           |
| 悲观锁       | 每次获取资源加锁                                             | 写多读少           |
| 公平锁       | 多个线程按照申请锁的顺序来获取锁                             | 吞吐率低           |
| 非公平锁     | 多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待 | 吞吐率高，线程饿死 |
| 重入锁       | 同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁 | ReentrantLock      |
| 非重入锁     | 非可重入                                                     | 可能死锁           |
| 独享锁       | 互斥锁，锁一次只能被一个线程所持有                           | 大部分锁           |
| 共享锁       | 锁可被多个线程所持有；                                       | 读写锁中的读锁     |
| 自旋锁       | 循环等待，然后不断的判断锁是否能够被成功获取，默认10次       |                    |
| 适应性自旋锁 | 自旋次数不固定                                               |                    |



#### AQS

| AQS核心               | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| 内部类Node            | 有共享或独占模式、waitStatus等属性                           |
| FIFO队列              | 多线程争用资源被阻塞时会进入此队列                           |
| int state             | 同步状态，可自定义具体实现                                   |
| isHeldExclusively()   | 是否独占模式                                                 |
| tryAcquire(int)       | 独占方式。尝试获取资源，成功则返回true，失败则返回false      |
| tryRelease(int)       | 独占方式。尝试释放资源，成功则返回true，失败则返回false      |
| tryAcquireShared(int) | 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源 |
| tryReleaseShared(int) | 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 |

#### 常用类

CountDownLatch、ReentrantLock、ReadWriteLock、Semaphore

ThreadLocal、AtomicInteger

### Spring/SpringBoot

#### Springboot自动配置

<img src="https://cdn.jsdelivr.net/gh/iceblow/images/20220321175401.png" alt="image-20220321175401454" style="zoom: 33%;" />

#### 循环依赖

![image-20200706161709829](https://cdn.jsdelivr.net/gh/iceblow/images/20220324175501.png)

Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（`singletonObjects`）,二级缓存为早期曝光对象`earlySingletonObjects`，三级缓存为早期曝光对象工厂（`singletonFactories`）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！

”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“

答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。

### 微服务框架

#### Springcloud、dubbo比较

| 功能组件 | Spring Cloud                   | Dubbo                                            |
| -------- | ------------------------------ | ------------------------------------------------ |
| 底层     | Http协议Rest接口通信           | Netty NIO框架，TCP协议，Hession序列化完成RPC通信 |
| 通讯协议 | rest                           | dubbo、rest、grpc、Thrift，还有Dubbo3、dubbo2等  |
| 性能     | 报文更大占用带宽大，但rest灵活 | 性能较好，但强依赖                               |

#### 服务治理





#### 组件原理

### 架构设计

#### 架构图

<img src="https://cdn.jsdelivr.net/gh/iceblow/images/20220324174438.png" alt="image-20220324174438773" style="zoom: 33%;" />

#### 秒杀系统

| 设计方案     | 实现                                                 |
| ------------ | ---------------------------------------------------- |
| 独立部署     | 独立web服务器，后台服务、独立域名                    |
| 页面设计简单 | 简化页面商品信息                                     |
| 多级缓存     | 浏览器或APP缓存、CDN缓存、服务端本地缓存、分布式缓存 |
| 下单限流     | 全局下单计数器（redis实现）                          |



### 数据结构和算法

#### 限流算法

| 限流算法 | 原理                                   | 优点                       | 缺点                               | 场景                       |
| -------- | -------------------------------------- | -------------------------- | ---------------------------------- | -------------------------- |
| 固定窗口 | 统计一个周期内的请求量                 | 实现简单                   | 临界点问题                         | 普通限流                   |
| 滑动窗口 | 一个周期分为多个小窗口                 | 限流粒度较细               | 临界点问题，实现稍复杂             | 普通限流                   |
| 漏桶     | 桶里是请求，总量控制                   | 桶大小可控，可应对突发流量 | 无法精确控制流出速度               | 秒杀                       |
| 令牌桶   | 桶里是令牌，请求从桶里拿令牌，速率控制 | 速率可控                   | 突发大流量会丢弃许多请求，实现复杂 | 平稳限流，如访问第三方服务 |

### Redis

常用数据结构包括String、list、set、zset、hash、bitmap、Hyperloglog（基数）、geospatial（地理位置）。

#### 持久化

| 持久化方式 | 原理                                                        | 优点                                         | 缺点               |
| ---------- | ----------------------------------------------------------- | -------------------------------------------- | ------------------ |
| RDB        | 定期快照存储                                                | 体积小、恢复速度快，适合备份                 | 丢失部分数据       |
| AOF        | 追加写，记录每次对服务器写的操作                            | 数据完整                                     | 文件体积大，速度慢 |
| 混合模式   | 内存快照以⼀定的频率执⾏，在两次快照之间，使⽤ AOF ⽇志记录 | 不会出现⽂件过⼤的情况了，也可以避免重写开销 |                    |

#### zset有序集合

跳表是链表加多级索引的结构，原理是单向链表的二分查找。

<img src="https://cdn.jsdelivr.net/gh/iceblow/images/20220327003100.jpg" alt="img" style="zoom: 33%;" />

#### 部署方式

| 部署方式 | 原理和作用                                                   | 缺点                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------ |
| 单机     | 单机部署                                                     | 单机故障，性能差                     |
| 主从     | 主从读写分离：<br>主从均可读<br>写交给主库，然后同步到从库（全量、增量）<br />作用：数据冗余、负载均衡 | 主库挂了不能提供写，故障不能自动转移 |
| 哨兵     | 哨兵集群：哨兵是⼀个运⾏在特殊模式下的 Redis 进程<br>监控:周期性地给所有的主从库发送 PING 命令<br/>哨兵选举:主观客观下线、<br/>故障转移：筛选打分三轮选主(优先级、同步最接近、ID最小）<br />通知: 从库同步新主库，原主库下线<br />作用：高可用 |                                      |
| 集群     | ⽤哈希槽来处理数据和实例之间的映射关系,key使用crc16算法对16384取模后定位到槽<br/>客户端缓存hash槽信息，重定向机制move<br />有服务端集群和客户端集群，cluster是服务端集群 |                                      |

#### 渐进式Hash

Redis 默认使⽤了两个全局哈希表：哈希表12。默认使⽤ 1， 2 并没有被分配空间。随着数据逐步增多，Redis 开始执⾏ rehash

- 给哈希表 2 分配更⼤的空间
- 把哈希表 1 中的数据重新映射并拷⻉到哈希表 2 中（渐进式，只写入新表，先查老表查不到再查新表）
- 释放哈希表 1 的空间

#### LRU缓存淘汰算法

自己实现：单向链表，头部放最新数据。判断是否新数据（遍历是否存在），如果已存在，删除所在的节点，然后放在头节点；如果是新数据，判断是否有内存，没有的话就删除尾部节点，新数据都是放在头节点的。

#### 缓存穿透、雪崩

|          | 缓存穿透                                                     | 缓存击穿                                                     | 缓存雪崩                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 问题来源 | 缓存和数据库中都没有的数据                                   | 某个key缓存中没有但数据库中有，大量并发                      | 缓存key大批量失效，而查询数据量巨大                          |
| 场景     | 非法请求，id不存在或被删了                                   | 缓存时间到期                                                 | 大量key失效；redis宕机                                       |
| 解决方法 | 接口层增加校验<br />缓存空值，过期时间短<br />布隆过滤器判断key是否存在，不存在就返回 | 设置热点数据永远不过期<br />接口限流与熔断，降级<br />key更新加全局互斥锁 | 缓存过期时间设置随机<br />设置热点数据永不过期<br />热点数据均匀分布在不同的缓存数据库中 |



### Mysql

#### 锁

- 行锁：MVCC行级锁，对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。
- 表锁：锁粒度大，并发低
- 死锁：

#### 索引

B+树特点：m 叉树只存储索引（非叶子节点），并不真正存储数据，通过双向链表将叶子节点串联在一起，这样可以方便按区间查找。IO次数取决于b+数的高度h，3层的b+树可以表示上百万的数据。

索引优化：索引命中率、索引长度、组合索引（最左匹配）

#### 事务

#### 隔离级别

- 读取未提交：最低的隔离级别，允许脏读，也就是可能读取到其他会话中未提交事务修改的数据，**可能会导致脏读、幻读或不可重复读**。 
- 读取已提交： 只能读取到已经提交的数据。**可以阻止脏读，但是幻读或不可重复读仍有可能发****生**。 
- 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。 
- 可串行化：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行。 

MySQL 默认采用的 可重复读 隔离级别。

#### SQL优化

- 分析语句，是否加载了不必要的字段/数据。 
- 分析 SQL 执行计划（explain extended），思考可能的优化点，是否命中索引等。 
- 查看 SQL 涉及的表结构和索引信息。 
- 如果 SQL 很复杂，优化 SQL 结构。 
- 按照可能的优化点执行表结构变更、增加索引、SQL 改写等操作。 
- 查看优化后的执行时间和执行计划。 
- 如果表数据量太大，考虑分表。 
- 利用缓存，减少查询次数。 

### Zookeeper

#### 原理



#### 分布式锁

排它锁：在lock节点下创建临时子节点 ，只有一个客户端创建成功获取锁，未获取锁的节点同时在lock节点下创建子节点的watch变更事件，可以重新获取锁。

共享锁：创建临时顺序节点，对于写请求，如果自己不是序号最小的子节点，那么就进入等待；对于读请求如果所有比自己小的子节点都是读请求可以获取锁。

### 系统排查

### 分布式技术

#### 分布式事务

| Seata模式对比 | AT模式                                                       | TCC模式                                                      |
| :-----------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
|     场景      | 支持本地 ACID 事务的关系型数据库<br/>Java 应用，通过 JDBC 访问数据库 | 不依赖于底层数据资源的事务支持                               |
|   整体机制    | 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁<br/>二阶段：提交异步化，回滚通过一阶段的回滚日志进行反向补偿 | 两阶段提交模型：<br/>一阶段 prepare 行为<br/>二阶段 commit 或 rollback |
|    一阶段     | 事务1：获取本地锁，update语句，获取全局锁，提交本地事务，释放本地锁<br/>事务2：获取本地锁，update语句，重试等待全局锁 | 调用 **自定义** 的 prepare 逻辑                              |
|  二阶段提交   | 事务1：全局提交，释放全局锁<br/>事务2：等到全局锁，提交本地事务，释放本地锁 | 调用 **自定义** 的 commit 逻辑。                             |
|  二阶段回滚   | 事务1：重新获取本地锁（等待2释放），反向补偿更新提交<br/>事务2：等待全局锁超时，回滚本地事务，释放本地锁 | 调用 **自定义** 的 rollback 逻辑                             |

#### 分布式锁

| 排它锁 | mysql                                                        | zookeeper                                                    | redis                              |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 原理   | 表锁(不推荐）：写入一条记录，插入成功的获取到锁，删除记录释放锁<br/>乐观锁：行锁，CAS | X节点下创建子节点，只有一个client成功，其他节点创建子节点变更事件，重新获取锁 | redission实现多种锁                |
| 优点   | 简单、容易实现                                               | 高可用，不可重入                                             | 高可用、高性能                     |
| 缺点   | 单机故障、性能差、死锁                                       | 实现复杂，性能低于redis                                      | 锁失效时间控制不稳定，稳定性低于ZK |
| 场景   | 适合并发低、性能不高场景                                     | 适合大部分场景，性能要求不高                                 | 适合高性能、高并发场景             |

