---
layout: post
title: 【设计模式】代理模式
categories: [设计模式]
description: 设计模式
keywords: 设计模式
---

代理模式（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

我们通过一个简单的例子来解释一下这段话。

我们开发一个性能计数器 MetricsCollector 类，用来收集接口请求的原始数据，比如访问时间、处理时长等。

以下是最简单直接的实现：

```java
  public void login(String username, String password) {
    long startTimestamp = System.currentTimeMillis();
    // ... 省略login逻辑...
    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo("login", startTimestamp， responseTime);
    // 性能计数器
    metricsCollector.recordRequest(requestInfo);
```

上面的写法有两个问题。第一，性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。第二，收集接口请求的代码跟业务代码无关，业务类最好职责更加单一，只聚焦业务处理。

为了将框架代码和业务代码解耦，代理模式就派上用场了。

性能计数器

```java
@Slf4j
public class MetricsCollector {

    public void recordRequest(RequestInfo requestInfo) {
        log.info("MetricsCollector {}", requestInfo.toString());
    }
    
    @Data
    @ToString
    @AllArgsConstructor
    public static class RequestInfo {
        private String methodName;
        private long startTimestamp;
        private long responseTime;
    }
}
```

### 静态代理

#### 原始类

```java
// 接口
public interface IUserService {

    void login(String username, String password);
}

// 原始类（被代理类）
@Slf4j
public class UserService implements IUserService {

    @Override
    public void login(String username, String password) {
        // ...登录逻辑
        log.info("UserService login, username:{}, password:{}", username, password);
    }
}
```

#### 代理类

代理类 UserProxyService 和原始类 UserService 实现相同的接口 IUserService。UserService 类只负责业务功能。代理类 UserProxyService 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。

```java
public class UserProxyService implements IUserService {

    private UserService userService;
    private MetricsCollector metricsCollector;

    public UserProxyService(UserService userService, MetricsCollector metricsCollector) {
        this.userService = userService;
        this.metricsCollector = metricsCollector;
    }

    @Override
    public void login(String username, String password) {
        long startTimestamp = System.currentTimeMillis();

        userService.login(username, password);

        long endTimestamp = System.currentTimeMillis();
        long responseTime = endTimestamp - startTimestamp;
        metricsCollector.recordRequest(new MetricsCollector.RequestInfo("userService.login", startTimestamp, responseTime));
    }
}
```

#### 测试类

```java
@Slf4j
public class ProxyTest {

    private UserService userService = new UserService();
    private MetricsCollector metricsCollector = new MetricsCollector();

    @Test
    public void test() {
        // 委托代理类
        IUserService iUserService = new UserProxyService(userService, metricsCollector);
        iUserService.login("username123", "password456");
    }
}
```

#### 测试结果

```java
11:27:14.565 [main] INFO proxy.UserService - UserService login, username:username123, password:password456
11:27:14.570 [main] INFO proxy.MetricsCollector - MetricsCollector RequestInfo(methodName=userService.login, responseTime=5)
```

#### 如果原始类没使用接口呢？

参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。

但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？对于这种外部类的扩展，我们一般都是采用继承的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。原理很简单，代码省略。

### 动态代理

不过，刚刚的代码实现还是有点问题。一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类有很多个，我们需要针对每个类都创建一个代理类。

我们可以使用动态代理来解决这个问题。所谓动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。那如何实现动态代理呢？

Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的反射语法）。我们来看一下，如何用 Java 的动态代理来实现刚刚的功能。

#### 代理类

```java
public class MetricsCollectorProxy {

    private MetricsCollector metricsCollector;

    public MetricsCollectorProxy() {
        this.metricsCollector = new MetricsCollector();
    }

    public Object createProxy(Object proxiedObject) {
        Class[] interfaces = proxiedObject.getClass().getInterfaces();
        DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);
    }

  	/**
     * 实现InvocationHandler, 自定义代理的逻辑
     */
    private class DynamicProxyHandler implements InvocationHandler {
        private Object proxiedObject;

        public DynamicProxyHandler(Object proxiedObject) {
            this.proxiedObject = proxiedObject;
        }

       /**
         *
         * @param proxy
         * @param method 执行的方法
         * @param args 方法入参数组,可以是基本类型或对象
         * @return
         * @throws Throwable
         */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            long startTimestamp = System.currentTimeMillis();

          	// 方法的执行结果
            Object result = method.invoke(proxiedObject, args);

            long endTimestamp = System.currentTimeMillis();
            long responseTime = endTimestamp - startTimestamp;
            String methodName = proxiedObject.getClass().getName() + ":" + method.getName();
            metricsCollector.recordRequest(new MetricsCollector.RequestInfo(methodName, startTimestamp, responseTime));
            return result;
        }
    }
}
```

#### 测试类

```java
// 动态代理
    @Test
    public void test2() {
        MetricsCollectorProxy proxy = new MetricsCollectorProxy();
        IUserService iUserService = (IUserService) proxy.createProxy(new UserService());
        iUserService.login("username123", "password456");
    }
```

#### 测试结果

```java
13:59:00.895 [main] INFO proxy.UserService - UserService login, username:username123, password:password456
13:59:00.900 [main] INFO proxy.MetricsCollector - MetricsCollector MetricsCollector.RequestInfo(methodName=proxy.UserService:login, startTimestamp=1649224740893, responseTime=6)
```

实际上，Spring AOP 底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。

### 应用场景

#### 非功能性需求

代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理。

这部分工作都是可以在 Spring AOP 切面中完成的。前面我们也提到，Spring AOP 底层的实现原理就是基于动态代理。

#### RPC和缓存

实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。

我们再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以开发两个接口，一个支持缓存，一个支持实时查询。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。

### 总结

| 代理模式                                                     | 静态代理                                                     | 动态代理                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| 不改变原始类情况下，引入代理类给原始类附加功能。<br />场景1：监控、统计、鉴权、限流<br />场景2：RPC、缓存 | 每个类都创建一个代理类，但存在大量重复代码<br />实现1：代理类和原始类实现同样的接口<br />实现2：代理类继承原始类的方法 | 运行的时候动态地创建代理类，业务使用代理类替换掉原始类 |

