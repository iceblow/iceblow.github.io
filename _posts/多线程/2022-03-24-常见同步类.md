---
layout: post
title: AQS原理
categories: [多线程]
description: some word here
keywords: keyword1, keyword2
---

谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）。

### AQS抽象队列同步器

类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch等。

![img](https://cdn.jsdelivr.net/gh/iceblow/images/20220322155234.png)

#### 同步状态 state

同步器主要维护了同步状态`state`，一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。

```java
// 同步状态
private volatile int state;

protected final int getState() {
  return state;
}

protected final void setState(int newState) {
  state = newState;
}

protected final boolean compareAndSetState(int expect, int update) {
  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}

```

```java 

// 等待队列的头节点
private transient volatile Node head;

// 等待队列的尾节点
private transient volatile Node tail;
```

#### 独占和共享

AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

#### 常见同步类

以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

其他同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。

### 举例 ReentrantLock

下面以`ReentrantLock`举例简单说明，详细分析会放在重入锁文章：

```java
// 实现Lock接口
public class ReentrantLock implements Lock{
  
  // 同步器内部类
	private final Sync sync;
  
  // 定义内部类（继承AQS）
  abstract static class Sync extends AbstractQueuedSynchronizer {}  
  
  // 非公平锁的同步器
   static final class NonfairSync extends Sync {}
  
  // 公平锁的同步器
  static final class FairSync extends Sync {
    // 公平锁的区别在于，获取锁的时候判断当前线程是否同步队列的head节点
  }
  
  // 默认非公平锁
  public ReentrantLock() {
    sync = new NonfairSync();
  }

  // 构造公平锁还是非公平锁
  public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
  }
}
```

### 自定义同步类

从上面可以看出自定义同步类的实现条件

- 实现Lock接口，lock()和 unlock()方法，具体实现依赖Sync
- 自定义Sync（继承AQS）作为内部类，内部类实现tryAcquire()和tryRelease()。

具体的实现细节可以参考常见同步类。
